// Common procedural planet generator routines
// This is include file for the procedural planet generator shaders
// Copyright (C) 2012-2022  Vladimir Romanyuk @ Cosmographic Software
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.

#ifdef _VERTEX_

layout(location = 0) in vec4 in_vert_pos;
layout(location = 1) in vec4 in_vert_tex_coord;

out vec4  out_tex_coord;

void main()
{
    gl_Position = in_vert_pos;
    out_tex_coord = in_vert_tex_coord;
}

#else

in vec4 out_tex_coord;
#define in_tex_coord out_tex_coord

layout(location = 0) out vec4 out_color;

#define sea_level mareParams.x
#define snow_level lavaParams.y
#define randomize Randomize
#define main_freq mainParams.x
#define venus_magn textureParams.z
#define venus_freq textureParams.w
#define color_dist_magn colorParams.x
#define color_dist_freq colorParams.y
#define driven_darkening dunesParams.w
#define climate_pole climateParams.x
#define climate_tropic climateParams.y
#define climate_equator climateParams.z
#define climate_grass_min plantsParams1.x
#define climate_grass_max plantsParams1.y
#define climate_forest_min plantsParams1.z
#define climate_forest_max plantsParams1.w
#define climate_steppe_min plantsParams2.x
#define climate_steppe_max plantsParams2.y
#define climate_steppe_max plantsParams2.y
#define humidity plantsParams2.z
#define height_temp_grad lavaParams.w
#define beach_width riversParams.w
#define tropic_width climateParams.w
#define tropic_lat colorParams.w
#define icecap_lat colorParams.z
#define icecap_height mareParams.w
#define plants_curr_biome int(plantsParams2.w)
#define mare_freq mareParams.y
#define mare_density mareParams.z
#define terrace_prob mainParams.y
#define erosion canyonsParams.w
#define montes_magn montesParams.x
#define montes_freq montesParams.y
#define montes_fraction montesParams.z
#define montes_spiky montesParams.w
#define dunes_magn dunesParams.x
#define dunes_freq dunesParams.y
#define dunes_fraction dunesParams.z
#define hills_magn hillsParams.x
#define hills_freq hillsParams.y
#define hills_fraction hillsParams.zw
#define canyons_magn canyonsParams.x
#define canyons_freq canyonsParams.y
#define canyons_fraction canyonsParams.z
#define rivers_magn riversParams.x
#define rivers_freq riversParams.y
#define rivers_sin riversParams.z
#define rifts_magn riftsParams.x
#define rifts_freq riftsParams.y
#define rifts_sin riftsParams.z
#define eqridge_magn eqridgeParams.x
#define eqridge_min_lat eqridgeParams.y
#define eqridge_mod_magn eqridgeParams.z
#define eqridge_mod_freq eqridgeParams.w
#define cracks_magn cracksParams.x
#define cracks_freq cracksParams.y
#define cracks_octaves cracksParams.z
#define crater_magn craterParams.x
#define crater_freq craterParams.y
#define crater_density craterParams.z
#define crater_octaves craterParams.w
#define crater_rayed_factor cracksParams.w
#define volcanoes_magn volcanoParams1.x
#define volcanoes_radius volcanoParams2.z
#define volcanoes_freq volcanoParams1.y
#define volcanoes_density volcanoParams1.z
#define volcanoes_octaves volcanoParams1.w
#define volcanoes_flows volcanoParams2.y
#define volcanoes_temp volcanoParams2.w
#define volcanoes_activity volcanoParams2.x
#define lava_cover lavaParams.x

#define clouds_curr_layer cloudsParams2.x
#define clouds_num_layers cloudsParams2.y
#define clouds_tidally_locked mainParams.w
#define clouds_magn cloudsParams2.w
#define clouds_freq cloudsParams1.x
#define clouds_octaves cloudsParams1.y
#define clouds_stripe_zones cloudsParams1.z
#define clouds_stripe_twist cloudsParams1.w
#define clouds_stripe_fluct cloudsParams2.z
#define clouds_equatorial_cyclone_magn cycloneParams.x
#define clouds_equatorial_cyclones_freq cycloneParams.y
#define clouds_equatorial_cyclones_density cycloneParams.z
#define clouds_equatorial_cyclones_octaves cycloneParams.w
#define clouds_polar_cyclones_magn cycloneParams2.x
#define clouds_polar_cyclones_freq cycloneParams2.y
#define clouds_polar_cyclones_latitude cycloneParams2.z
#define clouds_polar_cyclones_octaves cycloneParams2.w

#define tex_scale textureParams.x

#define color_vary colorParams2.xyz
#define color_gamma colorParams2.www

#define sun_surf_temp lavaParams.z
#define sun_flow_magn vec2(color_dist_magn, crater_magn)
#define sun_flow_freq vec2(color_dist_freq, crater_freq)
#define sun_flow_octaves vec2(volcanoes_octaves, crater_octaves)
#define sun_gran_freq hills_freq
#define sun_gran_octaves cracks_octaves
#define sun_gran_distort dunes_magn
#define sun_gran_temp_distort canyons_magn
#define sun_spot_rad_inner climate_steppe_min
#define sun_spot_rad_outer climate_steppe_max
#define sun_spot_temp climate_forest_max
#define sun_spot_freq mare_freq
#define sun_spot_density mare_density
#define sun_spot_filament_temp climate_forest_min
#define sun_spot_filament_freq montes_freq
#define sun_gran_top_temp icecap_lat
#define sun_gran_bot_temp tropic_lat
#define sun_spot_max_lat climate_pole
#define sun_spot_min_lat climate_tropic

const float NO_DATA = -1e+38;
const vec3 STARS_RANDOMIZE = vec3(-0.4428662062, 0.6390675306, 0.3357337713);

vec2 unwrap_with_or(vec2 eq, vec2 option, vec2 _default) {
    if (option == eq) {
        return _default;
    } else {
        return option;
    }
}

vec3 unwrap_with_or(vec3 eq, vec3 option, vec3 _default) {
    if (option == eq) {
        return _default;
    } else {
        return option;
    }
}

float unwrap_with_or(float eq, float option, float _default) {
    bool is_eq = abs(option - eq) > 0.01;

    return option * float(is_eq) + _default * float(!is_eq);
}

#define unwrap_or(option, _default) unwrap_with_or(NO_DATA, option, _default)
#define unwrap_star_randomize_or(option, _default) unwrap_with_or(STARS_RANDOMIZE, option, _default)

vec3 get_surface_point()
{
    vec2 spherical;
    if (faceParams.w == 6.0)    // global
    {
        spherical.x = (in_tex_coord.x * 2.0 - 0.5) * PI;
        spherical.y = (0.5 - in_tex_coord.y) * PI;
        vec2 alpha = vec2(sin(spherical.x), cos(spherical.x));
        vec2 delta = vec2(sin(spherical.y), cos(spherical.y));
        return vec3(delta.y*alpha.x, delta.x, delta.y*alpha.y);
    }
    else                        // cubemap
    {
        spherical = in_tex_coord.xy * faceParams.z + faceParams.xy;
        vec3 p = normalize(vec3(spherical, 1.0));
        if (faceParams.w == 0.0)
            return vec3( p.z, -p.y, -p.x);  // neg_x
        else if (faceParams.w == 1.0)
            return vec3(-p.z, -p.y,  p.x);  // pos_x
        else if (faceParams.w == 2.0)
            return vec3( p.x, -p.z, -p.y);  // neg_y
        else if (faceParams.w == 3.0)
            return vec3( p.x,  p.z,  p.y);  // pos_y
        else if (faceParams.w == 4.0)
            return vec3(-p.x, -p.y, -p.z);  // neg_z
        else
            return vec3( p.x, -p.y,  p.z);  // pos_z
    }
}

float encode_temp(float temp) {
    return clamp(temp * (1000.0f / 65535.0f), 0.0f, 1.0f);
}

struct Sunspots {
    float spot_mask;
    float fila_mask;
    float filas;
};

Sunspots get_sun_spots(vec3 coords, vec3 randomize, NoiseParams noise) {
    vec3 binormal = normalize(coords);

    float _lat = abs(coords.y);

    noise.octaves = 8;

    Sunspots sunspots = Sunspots(1.0, 1.0, 0.0);

    float fi, rnd, t;
    vec4 cell;
    float rad_factor = 0.8 / sun_spot_density;

    float rad_inner = unwrap_or(sun_spot_rad_inner, 0.1f) * 2.0f;
    float rad_outer = unwrap_or(sun_spot_rad_outer, 0.175f) * 4.0f;

    noise.h = 0.8;

    vec3 dist = vec3(0.01f * noise_fbm_float(coords * 3.6 + randomize, noise)
        * dot(noise_u_float(coords + randomize), 120.0)
        + noise_fbm_float(coords + randomize, NoiseParams(8.8, 10, 0.8, 0.5, 0.0001))
    );
    coords += dist * 0.5;

    float lat = abs(coords.y);

    if (lat > sun_spot_max_lat * (1.0f + pow(0.1f, sun_spot_max_lat * 1.0)) || lat < sun_spot_min_lat) {
        sunspots.fila_mask = 0.0;
        sunspots.spot_mask = 1.0;
    } else {
        cell = cell2_noise_sphere(coords, sun_spot_freq * 0.3 * sun_spot_density);

        fi = acos(dot(binormal, normalize(cell.xyz - coords))) / TAU;

        t = saturate((cell.w * rad_factor - rad_inner) / (rad_outer - rad_inner));
        sunspots.spot_mask *= smoothstep(0.0, 0.2, t);
        sunspots.fila_mask *= (1.0 - smoothstep(0.0, 1.0, t)) * smoothstep(0.0, 0.0, t) * 0.85;
        sunspots.filas += noise_u_float(vec3(sun_spot_filament_freq * fi, rnd, rnd)) * t * 0.5;
    }

    return sunspots;
}

float get_sun_glow_map(vec3 coords) {
    float sun_flow_magn_x = unwrap_with_or(0.0f, sun_flow_magn.x, 1.0f);
    float sun_flow_freq_x = unwrap_with_or(0.0f, sun_flow_freq.x, sqrt(sun_gran_freq) / 3.0f);
    float sun_flow_octaves_x = unwrap_or(sun_flow_octaves.x, 15);
    float sun_flow_magn_y = unwrap_or(sun_flow_magn.y, 3.0f / sun_surf_temp);
    float sun_flow_freq_y = unwrap_or(sun_flow_freq.y, 0.0f);
    float sun_flow_octaves_y = unwrap_or(sun_flow_octaves.y, 15);

    vec3 randomize = unwrap_star_randomize_or(
        randomize,
        hash3(vec2(sun_surf_temp, sun_surf_temp))
    );

    NoiseParams noise = NoiseParams(
        2.218281828459,
        sun_gran_octaves,
        0.5,
        0.8,
        0.0001
    );

    vec3 point = coords * vec3(1.0) + randomize;
    vec3 dist = 2.5 * noise_fbm_vec3(point * 0.5, noise);

    noise.h = 0.0;
    noise.octaves = sun_flow_octaves_x;

    float flows_small = sun_flow_magn_x * 0.1
        * noise_fbm_float(point * pow(sun_flow_freq_x, 2.0f) + dist, noise);

    noise.octaves = sun_flow_octaves_y;

    float flows_large = sun_flow_magn_y * 0.1
        * noise_fbm_float(point * pow(sun_flow_freq_y, 2.0f) + dist, noise);

    noise.octaves = 2;

    point = coords * sun_gran_freq / 3.0f + randomize;
    dist = vec3(sun_gran_temp_distort * noise_fbm_float(point * 0.2, noise));

    vec2 cell = cell3_noise_vec2(point + dist);
    float gran = smoothstep(0.1, 1.0, sqrt(abs(cell.y - cell.x)));

    Sunspots sunspots = Sunspots(1.0, 0.0, 0.0);

    if (sun_spot_density > 0.01) {
        noise.octaves = 5;

        sunspots = get_sun_spots(coords, randomize, noise);
    }

    float fila_temp = unwrap_or(sun_spot_filament_temp, sun_gran_top_temp * 0.8);
    float spot_temp = unwrap_or(sun_spot_temp, sun_gran_bot_temp * 0.7);

    return (
        flows_large + flows_small
            + mix(
                sun_gran_bot_temp,
                sun_gran_top_temp,
                gran * min(sunspots.spot_mask + 0.04f, 1.0f)
            )
        )
        * mix(spot_temp, 1.0f, sunspots.spot_mask)
        * (1.0f - sunspots.fila_mask)
        + sunspots.fila_mask
        * mix(spot_temp * 0.85f, fila_temp, sunspots.filas);
}

float get_sun_height_map(vec3 coords) {
    float height = get_sun_glow_map(coords);

    height = soft_poly_min(height, 0.99, 0.3);
    height = soft_poly_max(height, 0.01, 0.3);

    return height;
}

#endif
